// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: posts.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCategoriesByPostIDs = `-- name: GetCategoriesByPostIDs :many
SELECT
    pc.post_id,
    c.id,
    c.name,
    c.slug,
    c.created_at
FROM post_categories pc
JOIN categories c ON c.id = pc.category_id
WHERE pc.post_id = ANY($1::uuid[])
`

type GetCategoriesByPostIDsRow struct {
	PostID    pgtype.UUID        `json:"post_id"`
	ID        pgtype.UUID        `json:"id"`
	Name      string             `json:"name"`
	Slug      string             `json:"slug"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetCategoriesByPostIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetCategoriesByPostIDsRow, error) {
	rows, err := q.db.Query(ctx, getCategoriesByPostIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategoriesByPostIDsRow
	for rows.Next() {
		var i GetCategoriesByPostIDsRow
		if err := rows.Scan(
			&i.PostID,
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentCountsByPostIDs = `-- name: GetCommentCountsByPostIDs :many
SELECT
    post_id,
    COUNT(*)::bigint AS comment_count
FROM comments
WHERE post_id = ANY($1::uuid[])
GROUP BY post_id
`

type GetCommentCountsByPostIDsRow struct {
	PostID       pgtype.UUID `json:"post_id"`
	CommentCount int64       `json:"comment_count"`
}

func (q *Queries) GetCommentCountsByPostIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetCommentCountsByPostIDsRow, error) {
	rows, err := q.db.Query(ctx, getCommentCountsByPostIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentCountsByPostIDsRow
	for rows.Next() {
		var i GetCommentCountsByPostIDsRow
		if err := rows.Scan(&i.PostID, &i.CommentCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLikeCountsByPostIDs = `-- name: GetLikeCountsByPostIDs :many
SELECT
    post_id,
    COUNT(*)::bigint AS like_count
FROM post_likes
WHERE post_id = ANY($1::uuid[])
GROUP BY post_id
`

type GetLikeCountsByPostIDsRow struct {
	PostID    pgtype.UUID `json:"post_id"`
	LikeCount int64       `json:"like_count"`
}

func (q *Queries) GetLikeCountsByPostIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetLikeCountsByPostIDsRow, error) {
	rows, err := q.db.Query(ctx, getLikeCountsByPostIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLikeCountsByPostIDsRow
	for rows.Next() {
		var i GetLikeCountsByPostIDsRow
		if err := rows.Scan(&i.PostID, &i.LikeCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostBySearchPaginated = `-- name: GetPostBySearchPaginated :many
SELECT p.id, p.author_id, p.title, p.slug, p.body, p.is_published, p.created_at, p.updated_at
FROM posts p
WHERE p.title ILIKE '%' || $1 || '%'
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type GetPostBySearchPaginatedParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) GetPostBySearchPaginated(ctx context.Context, arg GetPostBySearchPaginatedParams) ([]Post, error) {
	rows, err := q.db.Query(ctx, getPostBySearchPaginated, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUsername = `-- name: GetPostsByUsername :many
SELECT p.id, p.author_id, p.title, p.slug, p.body, p.is_published, p.created_at, p.updated_at
FROM posts p
JOIN users u ON u.id = p.author_id
WHERE u.username = $1
ORDER BY p.created_at DESC
`

func (q *Queries) GetPostsByUsername(ctx context.Context, username pgtype.Text) ([]Post, error) {
	rows, err := q.db.Query(ctx, getPostsByUsername, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsLikedByUsername = `-- name: GetPostsLikedByUsername :many
SELECT p.id, p.author_id, p.title, p.slug, p.body, p.is_published, p.created_at, p.updated_at
FROM post_likes pl
JOIN users u ON u.id = pl.user_id
JOIN posts p ON p.id = pl.post_id
WHERE u.username = $1
ORDER BY p.created_at DESC
`

func (q *Queries) GetPostsLikedByUsername(ctx context.Context, username pgtype.Text) ([]Post, error) {
	rows, err := q.db.Query(ctx, getPostsLikedByUsername, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserLikedPostIDs = `-- name: GetUserLikedPostIDs :many
SELECT post_id
FROM post_likes
WHERE user_id = $1
AND post_id = ANY($2::uuid[])
`

type GetUserLikedPostIDsParams struct {
	UserID  pgtype.UUID   `json:"user_id"`
	Column2 []pgtype.UUID `json:"column_2"`
}

func (q *Queries) GetUserLikedPostIDs(ctx context.Context, arg GetUserLikedPostIDsParams) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getUserLikedPostIDs, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var post_id pgtype.UUID
		if err := rows.Scan(&post_id); err != nil {
			return nil, err
		}
		items = append(items, post_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByIDs = `-- name: GetUsersByIDs :many
SELECT id, google_id, username, email, description, avatar_url, created_at, updated_at
FROM users
WHERE id = ANY($1::uuid[])
`

func (q *Queries) GetUsersByIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.GoogleID,
			&i.Username,
			&i.Email,
			&i.Description,
			&i.AvatarUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
